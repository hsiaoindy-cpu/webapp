<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>è¶…æ…¢è·‘æ©ŸWEB APPæ¨¡æ“¬</title>
  <style>
    body { 
      font-family: system-ui, -apple-system, "Noto Sans TC", sans-serif; 
      padding: 20px; 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      min-height: 100vh;
      margin: 0;
    }
    
    .container {
      max-width: 600px;
      margin: 0 auto;
      background: rgba(255,255,255,0.1);
      padding: 30px;
      border-radius: 15px;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    }
    
    h1, h2 {
      text-align: center;
      margin-bottom: 30px;
      font-size: 2em;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    
    h2 {
      font-size: 1.5em;
      margin-top: 30px;
    }
    
    button { 
      padding: 12px 20px; 
      font-size: 16px; 
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      width: 100%;
      margin-bottom: 15px;
    }
    
    #connectBtn {
      background: #4CAF50;
      color: white;
    }
    
    #connectBtn:hover {
      background: #45a049;
      transform: translateY(-2px);
    }
    
    #connectBtn:disabled {
      background: #666;
      cursor: not-allowed;
      transform: none;
    }
    
    #handshakeBtn, #stopBtn, #speedBtn, #slowBtn {
      background: #2196F3;
      color: white;
    }
    
    #handshakeBtn:hover, #stopBtn:hover, #speedBtn:hover, #slowBtn:hover {
      background: #1976D2;
    }
    
    #downloadBtn {
      background: #FF9800;
      color: white;
    }
    
    #downloadBtn:hover {
      background: #F57C00;
      transform: translateY(-2px);
    }
    
    #downloadBtn:disabled {
      background: #666;
      cursor: not-allowed;
      transform: none;
    }
    
    .data-display {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin: 20px 0;
    }
    
    .data-card {
      background: rgba(255,255,255,0.2);
      padding: 20px;
      border-radius: 10px;
      text-align: center;
    }
    
    .data-value {
      font-size: 2.5em;
      font-weight: bold;
      margin: 10px 0;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    
    .data-label {
      font-size: 1.1em;
      opacity: 0.9;
    }
    
    .data-unit {
      font-size: 0.8em;
      opacity: 0.7;
    }
    
    .recording-status {
      background: rgba(255, 152, 0, 0.3);
      border: 2px solid #FF9800;
      padding: 10px;
      border-radius: 8px;
      text-align: center;
      margin: 15px 0;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0% { opacity: 0.7; }
      50% { opacity: 1; }
      100% { opacity: 0.7; }
    }
    
    pre { 
      background: rgba(0,0,0,0.7); 
      color: #00ff00; 
      padding: 15px; 
      border-radius: 8px; 
      white-space: pre-wrap; 
      max-height: 300px;
      overflow-y: auto;
      font-size: 14px;
      margin-top: 20px;
      display: none;
    }
    
    .status {
      text-align: center;
      margin: 15px 0;
      padding: 10px;
      border-radius: 5px;
    }
    
    .status.connected {
      background: rgba(76, 175, 80, 0.3);
    }
    
    .status.disconnected {
      background: rgba(244, 67, 54, 0.3);
    }
    
    .controls {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
      margin: 20px 0;
    }
    
    .download-section {
      margin-top: 20px;
      padding: 15px;
      background: rgba(255,255,255,0.1);
      border-radius: 10px;
    }
    
    .music-control {
      background: rgba(255,255,255,0.1);
      padding: 20px;
      border-radius: 10px;
      margin-top: 20px;
    }
    
    .music-control .row { 
      display: flex;
      align-items: center;
      margin: 10px 0;
      gap: 10px;
    }
    
    .music-control input[type=range] { 
      flex: 1;
    }
    
    .music-control button {
      margin-bottom: 0;
    }
    
    .angle-speed-indicator {
      background: rgba(76, 175, 80, 0.3);
      border: 2px solid #4CAF50;
      padding: 15px;
      border-radius: 8px;
      text-align: center;
      margin: 15px 0;
      font-size: 1.1em;
    }
    
    footer { 
      text-align: center;
      font-size: 0.9em;
      opacity: 0.7;
      margin-top: 15px;
    }
    
    @media (max-width: 600px) {
      .data-display {
        grid-template-columns: 1fr;
      }
      .controls {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>WEB APPé€£ç·šæ¸¬è©¦</h1>
    
    <button id="connectBtn">ğŸ”— é€£æ¥è¶…æ…¢è·‘æ©Ÿ</button>
    
    <div class="status disconnected" id="status">
      â­• æœªé€£æ¥
    </div>
    
    <div class="controls">
      <button id="handshakeBtn" disabled>ğŸ¤ é–‹å§‹å‚³è¼¸</button>
      <button id="stopBtn" disabled>â¹ï¸ åœæ­¢å‚³è¼¸</button>
      <button id="speedBtn" disabled>ğŸƒ å¢åŠ é€Ÿåº¦</button>
      <button id="slowBtn" disabled>ğŸƒ é™ä½é€Ÿåº¦</button>
    </div>
    
    <div id="recordingStatus" style="display: none;" class="recording-status">
      ğŸ”´ è¨˜éŒ„ä¸­... å·²è¨˜éŒ„ <span id="recordCount">0</span> ç­†è³‡æ–™
    </div>
    
    <div class="data-display">
      <div class="data-card">
        <div class="data-label">å¿ƒç‡</div>
        <div class="data-value" id="heartRate">--</div>
        <div class="data-unit">BPM</div>
      </div>
      <div class="data-card">
        <div class="data-label">è¸æ¿è§’åº¦</div>
        <div class="data-value" id="tiltAngle">--</div>
        <div class="data-unit">åº¦</div>
      </div>
    </div>
    
    <div class="data-display">
      <div class="data-card">
        <div class="data-label">å°åŒ…åºè™Ÿ</div>
        <div class="data-value" id="packetSeq">--</div>
        <div class="data-unit">No.</div>
      </div>
      <div class="data-card">
        <div class="data-label">æ¥æ”¶æ¬¡æ•¸</div>
        <div class="data-value" id="packetCount">0</div>
        <div class="data-unit">æ¬¡</div>
      </div>
    </div>
    
    <div class="download-section">
      <button id="downloadBtn" disabled>ğŸ’¾ ä¸‹è¼‰ JSON è¨˜éŒ„</button>
      <div style="margin-top: 10px; font-size: 0.9em; opacity: 0.8;">
        å°‡ä¸‹è¼‰åŒ…å«é–‹å§‹/åœæ­¢æ™‚é–“åŠåŸå§‹è³‡æ–™çš„ JSON æª”æ¡ˆ
      </div>
    </div>
    
    <!-- Music Section -->
    <section id="music-section" class="music-control">
      <h2>éŸ³æ¨‚æ’­æ”¾æ§åˆ¶</h2>
      
      <div id="angleSpeedIndicator" class="angle-speed-indicator" style="display: none;">
        ğŸµ è‡ªå‹•æ’­æ”¾é€Ÿç‡ï¼š<span id="autoSpeedValue">1.00</span>x
        <br>
        <small>æ­¥é »ï¼š<span id="angleForSpeed">-- </span> SPM | ç‹€æ…‹ï¼š<span id="motionState">ç­‰å¾…ä¸­</span></small>
      </div>
      
      <div class="row">
        <button id="btnPlay">â–¶ï¸ Start</button>
        <button id="btnStop" disabled>â¹ï¸ Stop</button>
        <span>ç‹€æ…‹ï¼š<span id="audioStatus">å°šæœªè¼‰å…¥éŸ³æª”</span></span>
      </div>

      <div class="row">
        <label>åŸºç¤å€ç‡ <span id="rateVal">1.00</span>x</label>
        <input id="rate" type="range" min="0.25" max="2.0" step="0.01" value="1.00">
      </div>

      <div class="row">
        <label>éŸ³é‡ <span id="gainVal">0.80</span></label>
        <input id="gain" type="range" min="0" max="1" step="0.01" value="0.8">
      </div>

      <div class="row">
        <label><input id="loop" type="checkbox" checked> å¾ªç’°æ’­æ”¾</label>
        <input id="file" type="file" accept="audio/*">
      </div>

      <div class="row">
        <label><input id="enableAngleControl" type="checkbox" checked> å•Ÿç”¨æ­¥é »æ§åˆ¶é€Ÿåº¦</label>
      </div>

      <p style="font-size:0.9em;opacity:0.8;">
        BLE å‚³å…¥è¸æ¿è§’åº¦æœƒè‡ªå‹•è¨ˆç®—æ­¥é »ï¼Œä¸¦æ”¹è®Šæ’­æ”¾é€Ÿç‡
        <br>
        æ­¥é »è¨ˆç®—ï¼šåµæ¸¬è§’åº¦ä¸Šå‡/ä¸‹é™æ–¹å‘è®ŠåŒ–ä¾†è­˜åˆ¥å³°å€¼
        <br>
        <small>30 SPM (4ç§’2æ­¥) = 1.0x | 60 SPM (2ç§’2æ­¥) = 2.0x | 15 SPM (8ç§’2æ­¥) = 0.5x</small>
        <br>
        <small style="color:#ffeb3b;">âš ï¸ è§’åº¦è³‡æ–™æ¯50msæ›´æ–°ï¼Œä½†è®ŠåŒ–å¾ˆæ…¢ï¼Œéœ€æŒçºŒè¸æ­¥1-2ç§’å¾Œæ‰èƒ½æº–ç¢ºè¨ˆç®—æ­¥é »</small>
      </p>
    </section>

    <pre id="log"></pre>
    <footer>æœ¬ç³»çµ±ç¤ºç¯„ BLE æ„Ÿæ¸¬è³‡æ–™èˆ‡ WebAudio éŸ³æ¨‚äº’å‹•</footer>
  </div>

  <script>
    // ==================== å…¨åŸŸè®Šæ•¸ ====================
    let device = null;
    let server = null;
    let service = null;
    let characteristic = null;
    let isTransmitting = false;
    let packetCount = 0;
    let currentSpeedMode = 'SLOW';
    
    // è¨˜éŒ„ç›¸é—œè®Šæ•¸
    let currentSession = null;
    let isRecording = false;
    
    // AMB82 BLE æœå‹™ UUID
    const SERVICE_UUID = '12345678-1234-5678-9abc-123456789abc';
    const CHARACTERISTIC_UUID = '87654321-4321-8765-cba9-987654321cba';
    
    // WebAudio è®Šæ•¸
    let ctx, gainNode, source, buffer;
    let baseRate = 1.0, loop = true;
    let playing = false;
    let enableAngleControl = true;
    let currentTiltAngle = 0;
    
    // æ­¥é »è¨ˆç®—ç›¸é—œè®Šæ•¸
    let angleHistory = []; // ä¿å­˜æ‰€æœ‰è§’åº¦æ­·å² {angle, timestamp}
    let stepTimestamps = []; // è¨˜éŒ„æ­¥ä¼æ™‚é–“é»
    let lastPeakTime = 0;
    let lastPeakType = null; // 'min' æˆ– 'max'
    
    const LOW_ANGLE = -5;      // ç†è«–æœ€ä½é»
    const HIGH_ANGLE = 45;     // ç†è«–æœ€é«˜é»
    const MID_ANGLE = 20;      // ä¸­é–“è§’åº¦
    
    const ANGLE_HISTORY_DURATION = 10000; // ä¿ç•™ 10 ç§’çš„è§’åº¦æ­·å²
    const MIN_PEAK_INTERVAL = 300; // å…©å€‹å³°å€¼ä¹‹é–“çš„æœ€å°é–“éš”ï¼ˆæ¯«ç§’ï¼‰
    const PEAK_DETECTION_WINDOW = 1000; // å³°å€¼åµæ¸¬çª—å£ï¼ˆ1ç§’ï¼‰
    const STEP_HISTORY_MAX = 10; // ä¿ç•™æœ€è¿‘å¹¾æ­¥çš„æ™‚é–“è¨˜éŒ„
    const CADENCE_CALC_WINDOW = 4; // ç”¨æœ€è¿‘å¹¾æ­¥ä¾†è¨ˆç®—æ­¥é »
    const SPEED_UPDATE_INTERVAL = 3000; // æ¯3ç§’æ›´æ–°ä¸€æ¬¡æ’­æ”¾é€Ÿç‡
    
    let currentState = 'unknown'; // 'rising', 'falling', 'unknown'
    let lastStateChangeTime = 0;
    let lastSpeedUpdateTime = 0; // ä¸Šæ¬¡æ›´æ–°æ’­æ”¾é€Ÿç‡çš„æ™‚é–“
    
    const $ = sel => document.querySelector(sel);
    const setAudioStatus = t => $("#audioStatus").textContent = t;
    
    // ==================== æ­¥é »è¨ˆç®—å‡½æ•¸ ====================
    
    // æ·»åŠ è§’åº¦åˆ°æ­·å²è¨˜éŒ„
    const addAngleToHistory = (angle, timestamp) => {
      angleHistory.push({ angle, timestamp });
      
      // æ¸…ç†è¶…éä¿ç•™æ™‚é–“çš„è³‡æ–™
      const cutoffTime = timestamp - ANGLE_HISTORY_DURATION;
      angleHistory = angleHistory.filter(item => item.timestamp > cutoffTime);
    };
    
    // åœ¨æŒ‡å®šæ™‚é–“çª—å£å…§æ‰¾åˆ°æœ€å¤§/æœ€å°è§’åº¦
    const findPeakInWindow = (centerTime, windowMs, type = 'max') => {
      const startTime = centerTime - windowMs / 2;
      const endTime = centerTime + windowMs / 2;
      
      const windowData = angleHistory.filter(
        item => item.timestamp >= startTime && item.timestamp <= endTime
      );
      
      if (windowData.length === 0) return null;
      
      if (type === 'max') {
        return windowData.reduce((max, item) => 
          item.angle > max.angle ? item : max
        );
      } else {
        return windowData.reduce((min, item) => 
          item.angle < min.angle ? item : min
        );
      }
    };
    
    // åˆ¤æ–·ç•¶å‰é‹å‹•æ–¹å‘
    const detectMotionDirection = (angle, timestamp) => {
      if (angleHistory.length < 10) return 'unknown'; // éœ€è¦è¶³å¤ çš„æ­·å²è³‡æ–™
      
      // å–æœ€è¿‘ 1 ç§’çš„è³‡æ–™
      const recentData = angleHistory.filter(
        item => timestamp - item.timestamp <= 1000
      );
      
      if (recentData.length < 5) return currentState;
      
      // è¨ˆç®—è§’åº¦è®ŠåŒ–è¶¨å‹¢ï¼ˆç·šæ€§å›æ­¸çš„ç°¡åŒ–ç‰ˆæœ¬ï¼‰
      const firstHalf = recentData.slice(0, Math.floor(recentData.length / 2));
      const secondHalf = recentData.slice(Math.floor(recentData.length / 2));
      
      const avgFirst = firstHalf.reduce((sum, item) => sum + item.angle, 0) / firstHalf.length;
      const avgSecond = secondHalf.reduce((sum, item) => sum + item.angle, 0) / secondHalf.length;
      
      const diff = avgSecond - avgFirst;
      
      if (Math.abs(diff) < 1) return currentState; // è®ŠåŒ–å¤ªå°ï¼Œä¿æŒç•¶å‰ç‹€æ…‹
      
      return diff > 0 ? 'rising' : 'falling';
    };
    
    // åµæ¸¬å³°å€¼ï¼ˆæœ€é«˜é»æˆ–æœ€ä½é»ï¼‰
    const detectPeak = (angle, timestamp) => {
      // æ·»åŠ åˆ°æ­·å²è¨˜éŒ„
      addAngleToHistory(angle, timestamp);
      
      // éœ€è¦è¶³å¤ çš„æ­·å²è³‡æ–™æ‰èƒ½é–‹å§‹åµæ¸¬
      if (angleHistory.length < 20) {
        $("#motionState").textContent = "æ”¶é›†è³‡æ–™ä¸­...";
        return false; // è‡³å°‘ 1 ç§’çš„è³‡æ–™
      }
      
      // é˜²æ­¢éæ–¼é »ç¹çš„å³°å€¼åµæ¸¬
      if (timestamp - lastPeakTime < MIN_PEAK_INTERVAL) {
        return false;
      }
      
      // åˆ¤æ–·ç•¶å‰é‹å‹•æ–¹å‘
      const newDirection = detectMotionDirection(angle, timestamp);
      const directionChanged = (newDirection !== currentState && 
                               newDirection !== 'unknown' && 
                               currentState !== 'unknown');
      
      if (directionChanged) {
        log(`ğŸ“Š æ–¹å‘è®ŠåŒ–: ${currentState} â†’ ${newDirection}, è§’åº¦: ${angle.toFixed(1)}Â°`);
      }
      
      const prevState = currentState;
      currentState = newDirection;
      
      // æ›´æ–°ç‹€æ…‹é¡¯ç¤º
      if (currentState === 'rising') {
        $("#motionState").textContent = "ä¸Šå‡ä¸­ â†—";
      } else if (currentState === 'falling') {
        $("#motionState").textContent = "ä¸‹é™ä¸­ â†˜";
      }
      
      // æ–¹å‘è½‰è®Šæ™‚æ‰å¯èƒ½å‡ºç¾å³°å€¼
      if (!directionChanged) return false;
      
      let peakType = null;
      
      // å¾ä¸Šå‡è½‰ç‚ºä¸‹é™ = å¯èƒ½åˆ°é”æœ€é«˜é»
      if (prevState === 'rising' && newDirection === 'falling') {
        // åœ¨è½‰æŠ˜é»é™„è¿‘æ‰¾æœ€å¤§å€¼
        const peak = findPeakInWindow(timestamp, PEAK_DETECTION_WINDOW, 'max');
        
        if (peak && peak.angle > MID_ANGLE && lastPeakType !== 'max') {
          peakType = 'max';
          log(`ğŸ‘£ åµæ¸¬åˆ°æœ€é«˜é» - è§’åº¦: ${peak.angle.toFixed(1)}Â°, æ™‚é–“: ${new Date(peak.timestamp).toLocaleTimeString()}.${peak.timestamp % 1000}`);
        }
      }
      
      // å¾ä¸‹é™è½‰ç‚ºä¸Šå‡ = å¯èƒ½åˆ°é”æœ€ä½é»
      if (prevState === 'falling' && newDirection === 'rising') {
        // åœ¨è½‰æŠ˜é»é™„è¿‘æ‰¾æœ€å°å€¼
        const peak = findPeakInWindow(timestamp, PEAK_DETECTION_WINDOW, 'min');
        
        if (peak && peak.angle < MID_ANGLE && lastPeakType !== 'min') {
          peakType = 'min';
          log(`ğŸ‘£ åµæ¸¬åˆ°æœ€ä½é» - è§’åº¦: ${peak.angle.toFixed(1)}Â°, æ™‚é–“: ${new Date(peak.timestamp).toLocaleTimeString()}.${peak.timestamp % 1000}`);
        }
      }
      
      if (peakType) {
        lastPeakType = peakType;
        lastPeakTime = timestamp;
        lastStateChangeTime = timestamp;
        stepTimestamps.push(timestamp);
        
        // åªä¿ç•™æœ€è¿‘çš„æ­¥æ•¸è¨˜éŒ„
        if (stepTimestamps.length > STEP_HISTORY_MAX) {
          stepTimestamps.shift();
        }
        
        return true;
      }
      
      return false;
    };
    
    // è¨ˆç®—æ­¥é »ï¼ˆsteps per minute, SPMï¼‰
    const calculateCadence = () => {
      if (stepTimestamps.length < 2) return null;
      
      // ä½¿ç”¨æœ€è¿‘å¹¾æ­¥è¨ˆç®—å¹³å‡æ­¥é »
      const recentSteps = Math.min(CADENCE_CALC_WINDOW, stepTimestamps.length);
      const startTime = stepTimestamps[stepTimestamps.length - recentSteps];
      const endTime = stepTimestamps[stepTimestamps.length - 1];
      const timeSpan = (endTime - startTime) / 1000; // è½‰æ›ç‚ºç§’
      
      if (timeSpan === 0) return null;
      
      // è¨ˆç®—æ­¥é »ï¼ˆæ­¥/åˆ†é˜ï¼‰
      const stepsInSpan = recentSteps - 1;
      const spm = (stepsInSpan / timeSpan) * 60;
      
      return spm;
    };
    
    // å°‡æ­¥é »è½‰æ›ç‚ºæ’­æ”¾é€Ÿç‡
    const cadenceToPlaybackRate = (spm) => {
      if (!spm || spm <= 0) return 1.0;
      
      // ç·šæ€§æ˜ å°„ï¼š15 SPM -> 0.5x, 30 SPM -> 1.0x, 60 SPM -> 2.0x
      // const rate = (spm / 30);
      const rate = (spm / 10);
      
      return Math.max(0.5, Math.min(2.0, rate));
    };
    
    // æ›´æ–°éŸ³æ¨‚æ’­æ”¾é€Ÿç‡
    const updatePlaybackRateFromAngle = (angle) => {
      if (!enableAngleControl || !source || !playing) {
        return;
      }
      
      currentTiltAngle = angle;
      
      // åµæ¸¬æ­¥ä¼
      const timestamp = Date.now();
      const stepDetected = detectPeak(angle, timestamp);
      
      // è¨ˆç®—æ­¥é »
      const cadence = calculateCadence();
      
      if (cadence) {
        const newRate = cadenceToPlaybackRate(cadence);
        
        // å¹³æ»‘éæ¸¡åˆ°æ–°é€Ÿç‡
        source.playbackRate.setTargetAtTime(newRate, ctx.currentTime, 0.2);
        
        // æ›´æ–°é¡¯ç¤º
        $("#autoSpeedValue").textContent = newRate.toFixed(2);
        $("#angleForSpeed").textContent = `${cadence.toFixed(1)}`;
        $("#angleSpeedIndicator").style.display = "block";
        
        if (stepDetected) {
          log(`ğŸµ æ­¥é » ${cadence.toFixed(1)} SPM â†’ æ’­æ”¾é€Ÿç‡ ${newRate.toFixed(2)}x`);
        }
      } else if (stepTimestamps.length === 1) {
        // åªåµæ¸¬åˆ°ç¬¬ä¸€æ­¥ï¼Œé¡¯ç¤ºæç¤º
        $("#angleSpeedIndicator").style.display = "block";
        $("#autoSpeedValue").textContent = baseRate.toFixed(2);
        $("#angleForSpeed").textContent = "ç­‰å¾…ä¸­";
        if (stepDetected) {
          log('ğŸ‘£ å·²åµæ¸¬åˆ°ç¬¬ä¸€æ­¥ï¼Œè«‹ç¹¼çºŒè¸æ­¥ä»¥è¨ˆç®—æ­¥é »');
        }
      }
    };
    
    // ==================== é€šç”¨å·¥å…·å‡½æ•¸ ====================
    
    // æ—¥èªŒå‡½æ•¸
    const log = (...args) => {
      const timestamp = new Date().toLocaleTimeString();
      document.getElementById('log').textContent += `[${timestamp}] ${args.join(' ')}\n`;
      document.getElementById('log').scrollTop = document.getElementById('log').scrollHeight;
      console.log(...args);
    };
    
    // æ›´æ–°ç‹€æ…‹é¡¯ç¤º
    const updateStatus = (text, connected = false) => {
      const statusElement = document.getElementById('status');
      statusElement.textContent = text;
      statusElement.className = connected ? 'status connected' : 'status disconnected';
    };
    
    // å•Ÿç”¨/åœç”¨æ§åˆ¶æŒ‰éˆ•
    const updateButtons = (connected) => {
      document.getElementById('handshakeBtn').disabled = !connected;
      document.getElementById('stopBtn').disabled = !connected || !isTransmitting;
      document.getElementById('speedBtn').disabled = !connected;
      document.getElementById('slowBtn').disabled = !connected;
      document.getElementById('connectBtn').disabled = connected;
      document.getElementById('downloadBtn').disabled = !currentSession || isRecording;
    };
    
    // ==================== è³‡æ–™è¨˜éŒ„å‡½æ•¸ ====================
    
    // é–‹å§‹æ–°çš„è¨˜éŒ„æœƒè©±
    const startRecordingSession = () => {
      currentSession = {
        startTime: new Date().toISOString(),
        stopTime: null,
        deviceInfo: {
          deviceName: device?.name || 'Unknown Device',
          deviceId: device?.id || 'Unknown ID'
        },
        rawData: []
      };
      isRecording = true;
      
      document.getElementById('recordingStatus').style.display = 'block';
      document.getElementById('recordCount').textContent = '0';
      
      log('ğŸ“ é–‹å§‹è¨˜éŒ„æœƒè©±:', currentSession.startTime);
    };
    
    // åœæ­¢è¨˜éŒ„æœƒè©±
    const stopRecordingSession = () => {
      if (currentSession && isRecording) {
        currentSession.stopTime = new Date().toISOString();
        isRecording = false;
        
        document.getElementById('recordingStatus').style.display = 'none';
        
        log('ğŸ è¨˜éŒ„æœƒè©±çµæŸ:', currentSession.stopTime);
        log(`ğŸ“Š æœ¬æ¬¡è¨˜éŒ„å…± ${currentSession.rawData.length} ç­†è³‡æ–™`);
        
        updateButtons(true);
      }
    };
    
    // æ·»åŠ è³‡æ–™åˆ°ç•¶å‰è¨˜éŒ„æœƒè©±
    const addDataToSession = (rawPacket) => {
      if (currentSession && isRecording) {
        currentSession.rawData.push({
          timestamp: new Date().toISOString(),
          rawPacket: rawPacket
        });
        
        document.getElementById('recordCount').textContent = currentSession.rawData.length.toString();
      }
    };
    
    // ä¸‹è¼‰ JSON æª”æ¡ˆ
    const downloadJSON = () => {
      if (!currentSession) {
        log('âŒ æ²’æœ‰å¯ä¸‹è¼‰çš„è¨˜éŒ„');
        return;
      }
      
      const startTime = new Date(currentSession.startTime);
      const fileName = `jogger_data_${startTime.getFullYear()}${(startTime.getMonth()+1).toString().padStart(2,'0')}${startTime.getDate().toString().padStart(2,'0')}_${startTime.getHours().toString().padStart(2,'0')}${startTime.getMinutes().toString().padStart(2,'0')}${startTime.getSeconds().toString().padStart(2,'0')}.json`;
      
      const jsonData = JSON.stringify(currentSession, null, 2);
      
      const blob = new Blob([jsonData], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      log('ğŸ’¾ JSON æª”æ¡ˆå·²ä¸‹è¼‰:', fileName);
      log(`ğŸ“ æª”æ¡ˆåŒ…å« ${currentSession.rawData.length} ç­†è¨˜éŒ„`);
    };
    
    // ==================== BLE é€šè¨Šå‡½æ•¸ ====================
    
    // è§£æè³‡æ–™å°åŒ…
    const parseDataPacket = (data) => {
      try {
        const text = new TextDecoder().decode(data);
        
        const match = text.match(/<(\d)(\d{3})([+-]\d{3})>/);
        if (match) {
          const sequence = parseInt(match[1]);
          const heartRate = parseInt(match[2]);
          const tiltAngle = parseInt(match[3]) / 10.0;
          const rawPacket = match[0];
          
          document.getElementById('packetSeq').textContent = sequence;
          document.getElementById('heartRate').textContent = heartRate;
          document.getElementById('tiltAngle').textContent = tiltAngle.toFixed(1);
          document.getElementById('packetCount').textContent = ++packetCount;
          
          addDataToSession(rawPacket);
          
          // æ ¹æ“šè§’åº¦æ›´æ–°éŸ³æ¨‚æ’­æ”¾é€Ÿç‡
          updatePlaybackRateFromAngle(tiltAngle);
          
          return true;
        } else {
          log('âš ï¸ éæ¨™æº–å°åŒ…æ ¼å¼:', text);
          return false;
        }
      } catch (error) {
        log('âŒ è§£æéŒ¯èª¤:', error.message);
        return false;
      }
    };
    
    // ç™¼é€å‘½ä»¤åˆ° AMB82
    const sendCommand = async (command) => {
      if (!characteristic) {
        log('âŒ ç‰¹å¾µå€¼æœªåˆå§‹åŒ–');
        return false;
      }
      
      try {
        log('ğŸ“¤ ç™¼é€å‘½ä»¤:', command);
        const encoder = new TextEncoder();
        const data = encoder.encode(command);
        await characteristic.writeValue(data);
        return true;
      } catch (error) {
        log('âŒ ç™¼é€å‘½ä»¤å¤±æ•—:', error.message);
        return false;
      }
    };
    
    // ==================== äº‹ä»¶ç›£è½å™¨ ====================
    
    // é€£æ¥è¨­å‚™
    document.getElementById('connectBtn').addEventListener('click', async () => {
      try {
        if (!navigator.bluetooth) {
          log('âŒ æ­¤ç€è¦½å™¨ä¸æ”¯æ´ Web Bluetooth API');
          return;
        }
        
        log('ğŸ” æœå°‹è¶…æ…¢è·‘æ©Ÿ...');
        updateStatus('ğŸ” æœå°‹è¨­å‚™ä¸­...');
        
        device = await navigator.bluetooth.requestDevice({
          filters: [
            { name: 'AMB82-YL-Device' },
            { namePrefix: 'AMB82' }
          ],
          optionalServices: [SERVICE_UUID]
        });
        
        log('âœ… å·²é¸æ“‡è¨­å‚™:', device.name || '(ç„¡åç¨±)');
        
        updateStatus('ğŸ”— é€£æ¥ä¸­...');
        server = await device.gatt.connect();
        log('ğŸ”— å·²é€£æ¥ GATT ä¼ºæœå™¨');
        
        service = await server.getPrimaryService(SERVICE_UUID);
        log('ğŸ”§ å·²ç²å–æœå‹™');
        
        characteristic = await service.getCharacteristic(CHARACTERISTIC_UUID);
        log('ğŸ“¡ å·²ç²å–ç‰¹å¾µå€¼');
        
        await characteristic.startNotifications();
        log('ğŸ”” å·²å•Ÿç”¨é€šçŸ¥');
        
        characteristic.addEventListener('characteristicvaluechanged', (event) => {
          parseDataPacket(event.target.value);
        });
        
        device.addEventListener('gattserverdisconnected', () => {
          log('ğŸ”Œ è¨­å‚™å·²æ–·ç·š');
          updateStatus('â­• è¨­å‚™æ–·ç·š');
          updateButtons(false);
          isTransmitting = false;
          
          if (isRecording) {
            stopRecordingSession();
          }
        });
        
        updateStatus('âœ… å·²é€£æ¥', true);
        updateButtons(true);
        log('ğŸ‰ é€£æ¥æˆåŠŸï¼å¯ä»¥é–‹å§‹å‚³è¼¸äº†');
        
      } catch (error) {
        log('âŒ é€£æ¥å¤±æ•—:', error.message);
        updateStatus('âŒ é€£æ¥å¤±æ•—');
        updateButtons(false);
      }
    });
    
    // å‚³è¼¸é–‹å§‹
    document.getElementById('handshakeBtn').addEventListener('click', async () => {
      if (await sendCommand('<HELLOYL>\n\r')) {
        log('ğŸ¤ ç™¼é€å‚³è¼¸å‘½ä»¤ï¼Œç­‰å¾…å›æ‡‰...');
        isTransmitting = true;
        
        startRecordingSession();
        
        updateButtons(true);
        updateStatus('ğŸ“¡ è³‡æ–™å‚³è¼¸ä¸­', true);
      }
    });
    
    // åœæ­¢å‚³è¼¸
    document.getElementById('stopBtn').addEventListener('click', async () => {
      if (await sendCommand('<BYEYL>\n\r')) {
        log('â¹ï¸ ç™¼é€åœæ­¢å‘½ä»¤');
        isTransmitting = false;
        
        stopRecordingSession();
        
        updateButtons(true);
        updateStatus('â¸ï¸ å‚³è¼¸å·²åœæ­¢', true);
      }
    });
    
    // å¢åŠ é€Ÿåº¦
    document.getElementById('speedBtn').addEventListener('click', async () => {
      const nextMode = 'FAST';
      if (await sendCommand(nextMode)) {
        currentSpeedMode = nextMode;
        log(`ğŸš€ åˆ‡æ›åˆ° ${currentSpeedMode} æ¨¡å¼`);
      }
    });

    // é™ä½é€Ÿåº¦
    document.getElementById('slowBtn').addEventListener('click', async () => {
      const nextMode = 'SLOW';
      if (await sendCommand(nextMode)) {
        currentSpeedMode = nextMode;
        log(`ğŸš€ åˆ‡æ›åˆ° ${currentSpeedMode} æ¨¡å¼`);
      }
    });    
    
    // ä¸‹è¼‰æŒ‰éˆ•äº‹ä»¶
    document.getElementById('downloadBtn').addEventListener('click', () => {
      downloadJSON();
    });
    
    // ==================== WebAudio éŸ³æ¨‚æ’­æ”¾ ====================
    
    async function ensureCtx() {
      if (!ctx) {
        ctx = new (window.AudioContext || window.webkitAudioContext)();
        gainNode = ctx.createGain();
        gainNode.gain.value = 0.8;
        gainNode.connect(ctx.destination);
      }
      if (ctx.state === "suspended") await ctx.resume();
    }

    async function decodeFile(file) {
      await ensureCtx();
      const arr = await file.arrayBuffer();
      buffer = await ctx.decodeAudioData(arr);
      setAudioStatus(`å·²è¼‰å…¥ ${file.name} (${buffer.duration.toFixed(1)}s)`);
    }

    function startPlay() {
      if (!buffer) return setAudioStatus("å°šæœªè¼‰å…¥éŸ³æª”");
      stopPlay();
      source = ctx.createBufferSource();
      source.buffer = buffer;
      source.loop = loop;
      
      // ä½¿ç”¨åŸºç¤é€Ÿç‡ä½œç‚ºåˆå§‹é€Ÿç‡
      source.playbackRate.value = baseRate;
      
      source.connect(gainNode);
      source.start();
      playing = true;
      $("#btnPlay").disabled = true;
      $("#btnStop").disabled = false;
      setAudioStatus("æ’­æ”¾ä¸­â€¦");
      
      if (enableAngleControl) {
        $("#angleSpeedIndicator").style.display = "block";
        log('ğŸµ éŸ³æ¨‚æ’­æ”¾å·²å•Ÿå‹•ï¼Œå°‡æ ¹æ“šæ­¥é »è‡ªå‹•èª¿æ•´é€Ÿç‡');
        log('ğŸ’¡ è«‹é–‹å§‹è¸æ­¥ï¼Œç³»çµ±æœƒåœ¨åµæ¸¬åˆ°æ­¥ä¼å¾Œèª¿æ•´é€Ÿç‡');
      }
    }

    function stopPlay() {
      if (source) { 
        try { source.stop(); } catch(e){} 
        source.disconnect(); 
        source = null; 
      }
      playing = false;
      $("#btnPlay").disabled = false;
      $("#btnStop").disabled = true;
      $("#angleSpeedIndicator").style.display = "none";
      setAudioStatus("åœæ­¢æ’­æ”¾");
    }

    $("#btnPlay").addEventListener("click", startPlay);
    $("#btnStop").addEventListener("click", stopPlay);
    
    $("#file").addEventListener("change", async e => {
      const f = e.target.files[0]; 
      if (f) { 
        await decodeFile(f); 
        startPlay(); 
      }
    });
    
    $("#rate").addEventListener("input", e => {
      baseRate = parseFloat(e.target.value);
      $("#rateVal").textContent = baseRate.toFixed(2);
      
      // å¦‚æœæ²’æœ‰å•Ÿç”¨è§’åº¦æ§åˆ¶ï¼Œç›´æ¥æ›´æ–°æ’­æ”¾é€Ÿç‡
      if (source && !enableAngleControl) {
        source.playbackRate.setTargetAtTime(baseRate, ctx.currentTime, 0.05);
      }
    });
    
    $("#gain").addEventListener("input", e => {
      const g = parseFloat(e.target.value);
      $("#gainVal").textContent = g.toFixed(2);
      if (gainNode) gainNode.gain.setTargetAtTime(g, ctx.currentTime, 0.05);
    });
    
    $("#loop").addEventListener("change", e => loop = e.target.checked);
    
    $("#enableAngleControl").addEventListener("change", e => {
      enableAngleControl = e.target.checked;
      
      if (enableAngleControl) {
        log('âœ… å•Ÿç”¨æ­¥é »æ§åˆ¶æ’­æ”¾é€Ÿç‡');
        if (playing) {
          // é‡ç½®æ­¥é »è¨ˆç®—
          stepTimestamps = [];
          lastPeakType = null;
          lastPeakTime = 0;
          angleHistory = [];
          currentState = 'unknown';
          lastStateChangeTime = 0;
        }
      } else {
        log('âŒ åœç”¨æ­¥é »æ§åˆ¶æ’­æ”¾é€Ÿç‡ï¼Œä½¿ç”¨åŸºç¤å€ç‡');
        $("#angleSpeedIndicator").style.display = "none";
        if (source && playing) {
          source.playbackRate.setTargetAtTime(baseRate, ctx.currentTime, 0.1);
        }
      }
    });
    
    // ==================== åˆå§‹åŒ– ====================
    
    const initApp = async () => {
      log('ğŸš€ AMB82 å¿ƒè·³è§’åº¦ç›£æ¸¬ç³»çµ±å·²å•Ÿå‹•ï¼ˆæ­¥é »åµæ¸¬å„ªåŒ–ç‰ˆï¼‰');
      log('ğŸ’¡ åŠŸèƒ½èªªæ˜ï¼š');
      log('   â€¢ é»æ“Šã€Œé–‹å§‹å‚³è¼¸ã€æœƒè‡ªå‹•é–‹å§‹è¨˜éŒ„è³‡æ–™');
      log('   â€¢ é»æ“Šã€Œåœæ­¢å‚³è¼¸ã€æœƒåœæ­¢è¨˜éŒ„ä¸¦å¯ä¸‹è¼‰ JSON');
      log('   â€¢ JSON æª”æ¡ˆåŒ…å«é–‹å§‹/çµæŸæ™‚é–“åŠåŸå§‹å°åŒ…è³‡æ–™');
      log('   â€¢ ç³»çµ±æœƒåˆ†æè§’åº¦è®ŠåŒ–è¶¨å‹¢åµæ¸¬å³°å€¼ï¼ˆæœ€é«˜é»/æœ€ä½é»ï¼‰');
      log('   â€¢ æ­¥é » 15~60 SPM å°æ‡‰é€Ÿç‡ 0.5x ~ 2.0x');
      log('   â€¢ åŸºæº–ï¼š30 SPM (4ç§’2æ­¥) = 1.0x');
      log('   â€¢ âš ï¸ è§’åº¦æ›´æ–°é »ç¹ä½†è®ŠåŒ–æ…¢ï¼Œéœ€æŒçºŒè¸æ­¥1-2ç§’æ‰èƒ½è¨ˆç®—æ­¥é »');
      updateStatus('ğŸ“± è«‹å…ˆé€£æ¥è¨­å‚™');
    };
    
    // å•Ÿå‹•æ‡‰ç”¨
    initApp();
    
  </script>
</body>
</html>